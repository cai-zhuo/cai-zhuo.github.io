<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://c739557637.github.io</id>
    <title>Gridea</title>
    <updated>2020-04-04T04:14:14.625Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://c739557637.github.io"/>
    <link rel="self" href="https://c739557637.github.io/atom.xml"/>
    <subtitle>看着自己</subtitle>
    <logo>https://c739557637.github.io/images/avatar.png</logo>
    <icon>https://c739557637.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[EVENT LOOP]]></title>
        <id>https://c739557637.github.io/post/event-loop/</id>
        <link href="https://c739557637.github.io/post/event-loop/">
        </link>
        <updated>2020-04-04T03:21:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="在javascript运行机制中依赖event-loop决定代码先后执行的顺序">在JavaScript运行机制中，依赖EVENT LOOP，决定代码先后执行的顺序。</h2>
<p>Javascript执行过程</p>
<ol>
<li>执行栈内任务，遇到setTimeout，setImmediate，等API，将回调放入宏队列，遇到process.nextTick,Promise等，将回调放入微队列</li>
<li>将微队列的任务逐个推入主线程，将遇到的API回调放入相应队列</li>
<li>微队列空时并且栈空，将宏队列的任务逐个推到主线程</li>
<li>宏队列空时，将微队列的任务推入主线程（在nodeJS中，宏队列的每个阶段执行完毕时，都会去执行微队列）</li>
<li>直到所有队列任务执行完毕。</li>
</ol>
<ul>
<li>
<p>javaScript中。分为主线程（STACK），其他线程（WEB APIs,others），宏队列（macrotask），微队列(microtask)。</p>
</li>
<li>
<p>区别</p>
<ol>
<li>
<p>在浏览器中，微队列可以认为在宏队列之内</p>
<img src="https://segmentfault.com/img/remote/1460000016278118?w=710&amp;h=749" alt="browser-eventloop" style="zoom: 67%;" />
</li>
<li>
<p>在nodeJS中，微队列在宏队列之间，宏队列和微队列分为各个不同的队列</p>
<p>各队列同样依靠一个循环来决定执行顺序。</p>
<p><mark>宏队列</mark></p>
<img src="https://segmentfault.com/img/remote/1460000016278121?w=951&amp;h=526" alt="node-eventloop" style="zoom: 80%;" />
<p><mark>微队列</mark></p>
 <img src="https://segmentfault.com/img/remote/1460000016278122?w=420&amp;h=433" alt="node-microtaskqueue" style="zoom: 80%;" /> 
</li>
<li>
<p>在微队列中，NextTick QUeue优先于Other Micro Queue</p>
</li>
<li>
<p>在微队列周期中，新的任务进入了队列，那么这个任务也将在这个周期执行，但在宏队列中不是。</p>
</li>
<li>
<p>只有在栈空的时候才会考虑宏队列和微队列的任务</p>
<p>所以在事件执行时，手动触发 和 代码执行执行的顺序会有区别</p>
<pre><code class="language-js">div.addEventListener('click',()=&gt;{
    Promise.resolve().then(()=&gt;{
    	console.log(&quot;resolved&quot;);
	})
    setTimeout(()=&gt;{
        console.log(&quot;timeout&quot;)
    },0)
})
//方案1:
//tap twice  ...
//方案2:
//click();
//click()
</code></pre>
<p>结果如下</p>
<ul>
<li>
<p>tap twice..</p>
<blockquote>
<p>resolved</p>
<p>timeout</p>
<p>resolved</p>
<p>timeout</p>
</blockquote>
</li>
<li>
<p>run click() twice</p>
<blockquote>
<p>resolved</p>
<p>resolved</p>
<p>timeout</p>
<p>timeout</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javascript 技巧收集]]></title>
        <id>https://c739557637.github.io/post/javascript-ji-qiao-shou-ji/</id>
        <link href="https://c739557637.github.io/post/javascript-ji-qiao-shou-ji/">
        </link>
        <updated>2020-04-04T03:07:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>js通过valueOf获取引用类型的数字，toString获取引用类型的字符串</p>
</li>
<li>
<p>Math.floor (4.9) === 4</p>
<p>~~   4.9 ===  4</p>
<p>~~ - 4.9 === -5</p>
</li>
<li>
<p>取整 | 0</p>
<p>1.3 | 0 ===  1</p>
<p>-1.3 | 0 === -1</p>
</li>
<li>
<p>判断奇偶数</p>
<p>const num = 3</p>
<p>!! (num &amp; 1) === true</p>
<p>!! (num % 2) === true</p>
</li>
<li>
<p>强制参数（mandatory）</p>
<pre><code class="language-js">const mandatory = ()=&gt;{
    throw new Error('Missing Parameter!')
}

const foo = (bar = mandatory())=&gt;{
    return bar;
}
</code></pre>
</li>
<li>
<p>惰性载入函数</p>
<p>通过覆写函数，使得下一次不用再进行判断</p>
<pre><code class="language-js">function foo(){
    if(a != b){
        console.log('a')
    }else{
        console.log('b')
    }
}
//优化后
function foo(){
    if(a != b){
        foo = function(){
            console.log('a')
        }
    }else{
        foo = function(){
            console.log('b')
        }
    }
    foo();	// or return foo()
}
</code></pre>
</li>
<li>
<p>一次性函数</p>
<pre><code class="language-js">let foo = ()=&gt;{
    console.log('1')
    foo = ()=&gt;{
        console.log('2')
    }
}
</code></pre>
</li>
<li>
<p>按位取反巧用</p>
<pre><code class="language-js">~ 0  === -1  //true
~-1 ===   0 //true

const arr = [1,2,3];
~arr.indexOf(4) ? null :arr.push(4) ;
</code></pre>
</li>
</ol>
]]></content>
    </entry>
</feed>