<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czh.im</id>
    <title>CZh.IM</title>
    <updated>2020-10-28T01:14:02.258Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czh.im"/>
    <link rel="self" href="https://czh.im/atom.xml"/>
    <subtitle>watching myself</subtitle>
    <logo>https://czh.im/images/avatar.png</logo>
    <icon>https://czh.im/favicon.ico</icon>
    <rights>All rights reserved 2020, CZh.IM</rights>
    <entry>
        <title type="html"><![CDATA[响应式图片]]></title>
        <id>https://czh.im/post/xiang-ying-shi-tu-pian/</id>
        <link href="https://czh.im/post/xiang-ying-shi-tu-pian/">
        </link>
        <updated>2020-10-27T15:01:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="利用srcset-属性对-图片进行缩放">利用srcset 属性对 图片进行缩放</h2>
<pre><code class="language-js">function loadCustomScaleImage(src, density) {
  const img = new Image();

  img.src = src;
  // 原本图片大小的x倍像素密度，一个屏幕像素占据图片的x个像素
  // 等同于 srcset=&quot;./WechatIMG6.jpeg ${density}x&quot;
  img.srcset = `${src} ${density}x`;

  document.getElementById('scaleBox').appendChild(img);
}
</code></pre>
<h2 id="响应式图片">响应式图片</h2>
<pre><code class="language-js">/*
   响应式图片 利用 w 描述符 来计算像素密度
   设 img 中 sizes 规定的大小为 资源大小
   设 img 中 w 描述符 规定的大小为 描述大小
   计算过程为 描述大小 / 资源大小
   计算结果为 像素密度 也就是 x描述符的值

   假设该图片大小为 5068，资源大小默认为 窗口宽度(821)
   计算结果约为 6.172
   也就是等同于 srcset=&quot;./WechatIMG6.jpeg 6.172x&quot;
*/
function loadResponsiveImage(src, sizes) {
  const img = new Image();

  img.src = src;
  img.srcset = `${src} ${img.naturalWidth * shrink}w`;
  img.sizes = sizes + 'px';
  document.getElementById('responsiveBox').appendChild(img);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://czh.im/post-images/1603811012740.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[V8中形状和内联缓存是如何优化对象和数组的访问的]]></title>
        <id>https://czh.im/post/v8-zhong-xing-zhuang-he-nei-lian-huan-cun-shi-ru-he-you-hua-dui-xiang-he-shu-zu-de-fang-wen-de/</id>
        <link href="https://czh.im/post/v8-zhong-xing-zhuang-he-nei-lian-huan-cun-shi-ru-he-you-hua-dui-xiang-he-shu-zu-de-fang-wen-de/">
        </link>
        <updated>2020-10-27T04:40:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="javascript-引擎工作流程">JavaScript 引擎工作流程</h2>
<p>在 V8 中，JS引擎的工作流程如下，从源代码开始，由编译器解析成 AST，再交由解释器生成<strong>字节码</strong>。</p>
<p>为了使得代码运行的更快，V8 内部会将字节码和分析数据( profiling data ) 一起发送给 优化编译器，生成优化过的<strong>机器码</strong>。当生成的机器码在运行之前被假定为不正确的，会重新回退生成字节码。</p>
<figure data-type="image" tabindex="1"><img src="https://czh.im/post-images/1603811139477.svg" alt="" loading="lazy"></figure>
<ol>
<li>一般的 JS 引擎都会有一个解释器和优化编译器。其中解释器可以快速生成为优化的字节码，优化编译器会使用<strong>更长的时间</strong>生成<strong>运行更快</strong>的机器码</li>
<li>V8 的解释器被叫做 <strong>Ignition</strong>，优化编译器叫做<strong>Turbofan</strong></li>
</ol>
<h2 id="javascript-对象模型object-model">JavaScript 对象模型(Object Model)</h2>
<ol>
<li>
<p>属性的访问</p>
<p>在 ECMA 的规范中，所有JavaScript 的对象的键值对都会映射到一个叫 property 的字典表中。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://czh.im/post-images/1603811145711.svg" alt="" loading="lazy"></figure>
<p>除 <code>[[Value]]</code> 外，规范还定义了如下属性：</p>
<ul>
<li>
<p><code>[[Writable]]</code> 决定该属性是否可写</p>
</li>
<li>
<p><code>[[Enumerable]]</code> 决定对象是否可被遍历</p>
</li>
<li>
<p><code>[[Configurable]]</code> 决定该属性是否可被删除。</p>
<p>参考 MDN 对象元属性。</p>
</li>
</ul>
<p>[[ 双方括号 ]] 表示 引擎不会暴露给 JavaScript 的属性，但是可以通过 Object.getOwnPropertyDescriptor 来访问到。</p>
<p>在数组中也一样。数组就是特殊的对象。</p>
<ol start="2">
<li>
<p>属性访问的优化</p>
<p>在 JavaScript 中，对象的属性访问是最常见的操作，并且这个操作的速度将很大的影响程序运行的错误。</p>
<p>在实现上，引擎采用了一个形状（也叫 隐藏类）的机制。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://czh.im/post-images/1603811153746.svg" alt="" loading="lazy"></figure>
<p>具有相同属性名，并且顺序一样的对象会指向相同的 <strong>形状</strong>。形状记录了 除 [[value]] 以外的元信息，以及一个offset的整型属性。</p>
<p>而原本的对象只需要记录所有的值，存在一个列表中，访问时通过偏移量来访问即可。<strong>无论有多少个对象，只要它们具有相同的形状，我们只需要将它们的形状与键值属性信息存储一次</strong> 。</p>
<ol start="3">
<li>
<p>Transition 链和树</p>
<pre><code class="language-js">const object = {};
object.x = 5;
object.y = 6;
</code></pre>
<p>当代码中有这样的操作时，就会形成一个 transition链。</p>
<p>该对象在初始化时没有任何属性，因此它指向一个空的 shape。</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://czh.im/post-images/1603811162695.svg" alt="" loading="lazy"></figure>
<p>下一个语句为该对象添加值为 <code>5</code> 的属性 <code>“x”</code>，所以 JavaScript 引擎转向一个包含属性 <code>“x”</code> 的 Shape，并向 <code>JSObject</code> 的第一个偏移量为0处添加了一个值 <code>5</code>。</p>
<p>接下来一个语句添加了一个属性 <code>'y'</code>，引擎便转向另一个包含 <code>'x'</code> 和 <code>'y'</code> 的 Shape，并将值 <code>6</code> 附加到 <code>JSObject</code>（位于偏移量 <code>1</code> 处）。</p>
<p>我们不需要为每个 Shape 存储完整的属性表。相反，每个 Shape 只需要知道它引入的新属性。</p>
<pre><code>例如在此例中，我们不必在最后一个 Shape 中存储关于 `'x'` 的信息，因为它可以在更早的链上被找到。要做到这一点，每一个 Shape 都会与其之前的 Shape 相连。
</code></pre>
<pre><code class="language-js">const object1 = {};
object1.x = 5;
const object2 = {};
object2.y = 6;
</code></pre>
<p>而在这种情况下，我们必须进行分支操作。</p>
<figure data-type="image" tabindex="5"><img src="https://czh.im/post-images/1603811169890.svg" alt="" loading="lazy"></figure>
<p>形状的生成也并不意味着，总从空形状开始，这取决于一开始定义对象的值。</p>
<h2 id="内联缓存inline-caches-or-ics">内联缓存(inline caches or ICs)</h2>
<pre><code class="language-js">function getX(o) {
	return o.x;
}
</code></pre>
<p>当有了形状的机制，就可以为函数的参数访问进行优化</p>
<figure data-type="image" tabindex="6"><img src="https://czh.im/post-images/1603811177764.svg" alt="" loading="lazy"></figure>
<p>getX会被解析为两条指令</p>
<ul>
<li><code>get_by_id</code> 从第一个参数（<code>arg1</code>）中加载属性 <code>'x'</code> 值并将其存储到地址 <code>loc0</code> 中。</li>
<li><code>return loc0</code>  返回我们存储到 <code>loc0</code> 中的内容。</li>
</ul>
<p>引擎会将两个值嵌入到 <code>get_by_id</code> 指令中， shape 和偏移量。这样在下次查找参数的值时，如果形状没有发生改变，就可以直接通过偏移量来查找，跳过费时的属性信息查找，这比每次查找属性要快得多</p>
<h2 id="高效存储数组">高效存储数组</h2>
<pre><code class="language-js">const array = [
	'#jsconfeu',
];
</code></pre>
<p>考虑如上数组。</p>
<figure data-type="image" tabindex="7"><img src="https://czh.im/post-images/1603811187226.svg" alt="" loading="lazy"></figure>
<p>每个数组都有一个单独的 <em>elements backing store</em>，其中包含所有数组索引的属性值。JavaScript 引擎不必为数组元素存储任何属性特性，因为它们通常都是可写的，可枚举的以及可配置的。JavaScript 引擎利用这一点，将数组元素与其他命名属性分开存储。</p>
<p>由于上述操作将 数组元素的属性当做了默认的属性。所以讲数组元素放进 Elements 列表来处理。如果改变了数组元素的元属性呢</p>
<pre><code class="language-js">const array = Object.defineProperty(
	[],
	'0',
	{
		value: 'Oh noes!!1',
		writable: false,
		enumerable: false,
		configurable: false,
	}
);
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://czh.im/post-images/1603811193116.svg" alt="" loading="lazy"></figure>
<p>不要这样做，这样会导致 数组的元素 存放在一个 字典表里面（Dictionary Elements），这种方式来查找数组元素是缓慢且低效的。</p>
<p>因为不是通过下标偏移量来查找，而是当做了类似于普通对象的键值对查找，每个下标都对应一个属性特性 ( property attributes )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端工程化搭建 错误记录]]></title>
        <id>https://czh.im/post/qian-duan-gong-cheng-hua-da-jian-cuo-wu-ji-lu/</id>
        <link href="https://czh.im/post/qian-duan-gong-cheng-hua-da-jian-cuo-wu-ji-lu/">
        </link>
        <updated>2020-09-02T01:28:16.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>webpack 插件中，正确的html插件为 html-webpack-plugin , 而 webpack-html-plugin 会报错。</li>
<li>在使用 @typescript-eslint 时，eslintrc.js 文件中<br>
project 字段为 './tsconfig.json' ,但是此时会报一个编译错误。</li>
</ol>
<pre><code class="language-cmd">0:0  error  Parsing error: &quot;parserOptions.project&quot; has been set for
@typescript-eslint/parser.
The file does not match your project config: .eslintrc.js.
The file must be included in at least one of the projects provided
</code></pre>
<p>这个问题在 @typescript-eslint 的 github 上，作为 issue 已经被解决，但是在我这里仍然出现了问题，可能是版本问题。<br>
解决方法：</p>
<ol>
<li>正确的配置 tsconfig.json 中的 include 字段，确保只包含项目中的文件。</li>
<li>使用 extends 字段让 eslint 进行扩展。<br>
(详情)[https://github.com/typescript-eslint/typescript-eslint/issues/1159]</li>
<li>在 eslintrc.js 中 parserOptions 字段下 添加 createDefaultProgram: true<br>
这个方法可能会影响 IDE 使用相关eslint插件时的性能，但是可以解决上述问题。<br>
(详情)[https://github.com/typescript-eslint/typescript-eslint/issues/864]</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 配置 less]]></title>
        <id>https://czh.im/post/react-pei-zhi-less/</id>
        <link href="https://czh.im/post/react-pei-zhi-less/">
        </link>
        <updated>2020-06-04T11:33:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="导出webpack配置文件">导出webpack配置文件</h1>
<blockquote>
<p>yarn run eject<br>
在生成的config目录下修改webpack.config.js<br>
在 rules 中 cassLoader 下添加</p>
</blockquote>
<pre><code class="language-js">    let lessRegex = /\.less$/;
    let lessModuleRegex = /\.module\.less$/;
    //...
    {
            test:lessRegex,
            exclude: lessModuleRegex,
            use: getStyleLoaders(
                {
                    importLoaders: 3,
                    sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,
                },
                'less-loader'
            )
    },
    {
              test: lessModuleRegex,
              use: getStyleLoaders(
                  {
                    importLoaders: 3,
                    sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,
                    localsConvention: 'camelCase',
                    modules: {
                      getLocalIdent: getCSSModuleLocalIdent,
                    },
                  },
                  'less-loader',
              ),
            },
</code></pre>
<p>正常来说 css-modules ，文件命名为 index.module.less<br>
如果使 index.less 也具有 css-modules 的效果，就将 lessModuleRegex 换成 lessRegex ，并且去掉上一个 lessLoader 模块。</p>
<blockquote>
<p>yarn run start</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有关浏览器渲染（Compositing）]]></title>
        <id>https://czh.im/post/you-guan-liu-lan-qi-xuan-ran-compositing/</id>
        <link href="https://czh.im/post/you-guan-liu-lan-qi-xuan-ran-compositing/">
        </link>
        <updated>2020-05-20T05:32:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器渲染的过程">浏览器渲染的过程</h2>
<p>当浏览器拿到HTTP响应的HTML文件时，会去解析HTML的DOM结构。生成DOM Tree</p>
<p>对于解析到的link 标签，会进行并行下载，下载完成后解析，style标签会直接解析，link,style标签中的样式资源会生成 CSS Rule Tree。</p>
<p>而script标签分为三种情况。</p>
<ul>
<li>default	同步下载，暂停解析DOM结构</li>
<li>defer	异步下载，DOM解析完毕以后，执行JS文件</li>
<li>async     异步下载，下载完毕立即执行JS文件</li>
</ul>
<p>当浏览器启动渲染时，会走一个如下的机制。</p>
<p>​																		<br>
JS(AST,JIT)	--&gt;	宏脚本执行	--&gt;	Micro Task	--&gt;	Macro Task	--&gt;</p>
<p>DOM Tree + CSS Rule Tree	--&gt;	Render Tree	--&gt;	Layout	--&gt;	Paint	--&gt;	Compositing</p>
<ul>
<li>Render Tree	由Dom和CSS计算出的dom节点应具有的样式树</li>
<li>Layout      计算Dom节点的布局</li>
<li>Paint         计算DOm节点的渲染样式</li>
<li>Compositing   计算整个渲染过程可以分为几个图层，有合成器线程来执行。</li>
</ul>
<p>在这个过程执行完毕，又会回到Event Loop阶段，如果发生了对Dom的操作，将会判断回不回去走后续的流程，否则会一直循环在Event Loop。比如：</p>
<ul>
<li>Dom的布局发生了变化，会到Layout阶段（回流/reflow）</li>
<li>Dom的某些不影响布局的样式发生变化，回到Paint阶段（重绘/repaint）</li>
<li>对于那些属性会触发回流或者重绘，可以参考
<ul>
<li>https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/</li>
</ul>
</li>
</ul>
<p>对于Compositing阶段，浏览器中的Render Process，会分出一个 合成器线程，将整个渲染页面分多个图层来绘制（光栅化），然后将每个图层的纹理都交给GPU来渲染，不去让CPU计算渲染像素的规则，达到“加速”渲染的效果。</p>
<p>我们常用的CSS硬件加速（GPU加速）就是上述所说的策略</p>
<p>出发该策略有很多种方式，但也很复杂。我们可以采用最简单的一种方式。</p>
<ul>
<li>触发CSS的3D变换</li>
</ul>
<pre><code class="language-css">.cube {
   -webkit-transform: translateZ(0);
   -moz-transform: translateZ(0);
   -ms-transform: translateZ(0);
   -o-transform: translateZ(0);
   transform: translateZ(0);
   /* Other transform properties here */
}
</code></pre>
<blockquote>
<p>https://www.cnblogs.com/rubylouvre/p/3471490.html</p>
</blockquote>
<ul>
<li>will-change属性</li>
</ul>
<pre><code class="language-css">div{
  will-change:auto;	
}
/*
	will-change 的值是告诉浏览器有哪些属性会变化，auto就是让浏览器自己判断。
*/
</code></pre>
<h2 id="调试">调试</h2>
<p>对于浏览器渲染的调试，我们可以打开开发者工具</p>
<ul>
<li>按下ESC，在console旁边有 三个点 的可点击区域</li>
<li>点击 Rendering</li>
<li>勾选 Paint Flashing，Layout ，Layer</li>
</ul>
<p>我们就可以分别看到 重绘，回流，和 分层 的情况了。</p>
<h2 id="补充">补充</h2>
<p>在浏览器的某些事件中，会因等待JS的执行，判断是否阻止了事件的默认行为。<br>
这样的话，就不会立即交付任务与合成器线程，也就拖慢了渲染的速度。<br>
我们可以通过给事件加上 options 的 passive :true 选项,来告知浏览器，开发者不会阻止浏览器的默认行为，从而直接交付给合成器线程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器事件-passive]]></title>
        <id>https://czh.im/post/liu-lan-qi-shi-jian-passive/</id>
        <link href="https://czh.im/post/liu-lan-qi-shi-jian-passive/">
        </link>
        <updated>2020-05-18T02:25:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="浏览器事件-passive">浏览器事件-passive</h1>
<h2 id="targetaddeventlistnertypecallbackoptions">target.addEventListner('type',callback,options)</h2>
<h3 id="options">options</h3>
<ul>
<li>capture : 是否在事件的捕获阶段出发</li>
<li>once ： 最多只调用一次</li>
<li>passive ： 设置为true时，表示Listener永远不会调用preventDefault。如果listener仍调用，浏览器会在控制台发出一个警告。（MDN）</li>
</ul>
<h3 id="preventdefault">preventDefault</h3>
<blockquote>
<p>如果此事件没有被显式处理，它默认的动作也不应该照常执行。此事件还是继续传播，除非碰到事件侦听器调用stopPropagation() 或stopImmediatePropagation()，才停止传播。        ---MDN</p>
</blockquote>
<h3 id="render-process">render process</h3>
<p>在MDN文档中，对于passive和preventDefault只有简单的介绍，也就是简单的说明，preventDefault会组织默认事件，而passive表明我不会阻止默认事件。<br>
而在render process Compositing阶段，为了加速渲染，采用的是合成器渲染。也就是将一个页面分成多个图层，分别光栅化（渲染）。然后绘制成一个帧。<br>
假如在页面中，进行滚动，合成器就会预先将没有显示的部分，分层，光栅化，合成，发送到GPU，有GPU负责显示。<br>
如果我又在document元素上监听了scroll事件，此时，合成器就会先等待主线程执行JS，然后再进行上述操作，这样无疑会拖慢整个过程的平滑程度，甚至会出现掉帧。<br>
对合成器来说，监听事件的Dom对象所属的区域，称为 <strong>非快速滚动区域</strong> ，也就是执行慢的区域。<br>
而在监听事件中配置 passive : true.<br>
就会告诉合成器，这个地方可以先进行 分层，光栅化，合成，等一些列操作，等到事件出发的时候发送到GPU。而不用等待主线程执行完毕。</p>
<pre><code class="language-js">document.addEventListener('click',()=&gt;{},{passive:true});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[观察浏览器回调触发机制]]></title>
        <id>https://czh.im/post/guan-cha-liu-lan-qi-hui-diao-hong-fa-ji-zhi/</id>
        <link href="https://czh.im/post/guan-cha-liu-lan-qi-hui-diao-hong-fa-ji-zhi/">
        </link>
        <updated>2020-04-21T02:11:42.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章中，我们首先会通过一些API机制，观察回调执行的时机，在进行具体的分析。</p>
<h2 id="观察mo回调执行位置">观察MO回调执行位置</h2>
<p>我们先定义一些要使用的函数,用来观察observer()回调位置。</p>
<pre><code class="language-js">const observer = new MutationObserver(observe_callback);
let counter = 1;
const textNode = document.createTextNode(String(counter));

observer.observe(textNode, {
	characterData: true
});

function nextTick() {
        Promise.resolve().then(() =&gt; console.log('promise resolved'));
        timerFunc();
        setTimeout(() =&gt; console.log('timeout'));
    }

function changeNode() {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
}

function observe_callback() {
        console.log('observer alert');
}
</code></pre>
<p>我们猜测一下几种可能</p>
<ul>
<li>MO回调属于宏队列，在事件轮询中触发。</li>
<li>MO回调属于微队列，在事件轮询前触发。</li>
</ul>
<p>执行函数</p>
<pre><code class="language-js">nextTick();
</code></pre>
<p>执行结果</p>
<blockquote>
<p>promise resolved<br>
observer alert<br>
timeout</p>
</blockquote>
<p>通过调换 <strong>promise.resolve().then() <strong>和</strong>timerFunc</strong>  顺序</p>
<blockquote>
<p>observer alert<br>
promise resolved<br>
timeout</p>
</blockquote>
<p>发现 <strong>MO回调</strong> 和 <strong>promise回调</strong> 在微队列中执行顺序取决于注册顺序。</p>
<h2 id="将requestanimationframe回调加入观察顺序">将requestAnimationFrame回调加入观察顺序</h2>
<p>声明函数</p>
<pre><code class="language-js">function RAF_callback() {
	console.log('requestAnimationFrame callback');
}
</code></pre>
<p>修改函数</p>
<pre><code class="language-js">function nextTick() {
	requestAnimationFrame(RAF_callback) 	//推进RFA回调到下一帧的队列
    Promise.resolve().then(() =&gt; console.log('promise resolved')); //推进promise回调到下一帧队列
	changeNode();	//推进MO回调到下一帧队列
	setTimeout(() =&gt; console.log('timeout'));  //推进timeout回调到队列
}
</code></pre>
<p>函数执行</p>
<pre><code class="language-js">nextTick();
</code></pre>
<p>执行多次的结果</p>
<blockquote>
<p>promise resolved<br>
observer alert<br>
timeout<br>
requestAnimationFrame callback</p>
</blockquote>
<blockquote>
<p>promise resolved<br>
observer alert<br>
requestAnimationFrame callback	// -&gt;<br>
timeout												// -&gt;顺序发生了变化</p>
</blockquote>
<p>通过上面结果我们可以推测出</p>
<ul>
<li><strong>requestAnimationFrame回调</strong>属于宏队列事件，也就是该方法处于事件轮询中</li>
<li>而<strong>setTimeout回调</strong>和**requestAnimationFrame回调****具体谁先触发取决于，事件轮询到那个阶段。</li>
</ul>
<h2 id="分析">分析</h2>
<p>我们先分析一下，浏览器渲染每一帧都发生了什么。</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Czhuo%5CDesktop%5C1158202-6c6f3bf9f9b2c5eb.webp" alt="" loading="lazy"></figure>
<p><strong>JavaScript</strong> -&gt; <strong>Style</strong> -&gt; <strong>Layout</strong> -&gt; <strong>Paint</strong> -&gt; <strong>Composite</strong></p>
<blockquote>
<ul>
<li>
<p>JavaScript : js代码的执行和计算(包括事件循环机制)</p>
</li>
<li>
<p>Style : 确定每个DOM元素所应用的css规则</p>
</li>
<li>
<p>Layout : 计算每个DOM元素在最终屏幕上显示的大小和位置。由于web页面的元素布局是相对的，所以其中任意	一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫reflow(回流)。</p>
</li>
<li>
<p>Paint : 在多个层上绘制DOM元素的的文字、颜色、图像、边框和阴影等。</p>
</li>
<li>
<p>Composite : 按照合理的顺序合并图层然后显示到屏幕上</p>
<p>该部分来自 https://www.jianshu.com/p/a32b890c29b1</p>
</li>
</ul>
</blockquote>
<p>而 JavaScript 部分主要部分就是事件循环和微队列机制。</p>
<p>所以我们可以继续分析，以上函数回调的出发顺序。</p>
<p>当我们注册一个MO回调，promise回调，RFA回调，setTimeout回调，实在当前 JavaScript阶段注册。</p>
<p>而在下一帧在执行JavaScript阶段时，按照微队列和事件轮询机制触发回调。</p>
<blockquote>
<p>浏览器和node之间的事件轮询机制略有差异。</p>
<p>并且node版本不同也会有差异。在12.0以后基本和浏览器相同。</p>
<p>简单来说浏览器中的微队列在每个事件阶段<strong>之中</strong>，并且清空微队列在清空宏队列。</p>
<p>而12.0以前的node的微队列在每个事件<strong>之间</strong>，并且process.nextTick回调 优于 promise回调。</p>
</blockquote>
<pre><code class="language-js">   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
   //该图表来自node官方文档
</code></pre>
<p>我们再来看之前注册的回调都发生了什么</p>
<p>JavaScript 阶段 注册了MO回调，RFA回调，setTimeout回调，promise回调。</p>
<p>然后在下一帧执行JavaScript阶段，触发事件轮询机制。按机制触发注册的回调。</p>
<ul>
<li>先清空微队列，执行了promise回调和MO回调</li>
<li>再看当前处于哪个事件阶段，清空宏队列。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[if块级作用域函数声明的副作用]]></title>
        <id>https://czh.im/post/if-kuai-ji-zuo-yong-yu-han-shu-sheng-ming-de-fu-zuo-yong/</id>
        <link href="https://czh.im/post/if-kuai-ji-zuo-yong-yu-han-shu-sheng-ming-de-fu-zuo-yong/">
        </link>
        <updated>2020-04-15T07:04:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="情景">情景</h2>
<p>在一般情况下，我们都会注意到函数声明时，会将函数提升到整个块级作用域的顶层。<br>
<code>js var a = 1; if(true){ a = 2; function a(){} a = 3; } console.log(a) // a = 2;</code><br>
一般我们默认为，function a (){}  语句 会提升到块级作用域的顶端<br>
<code>js var a = 1; if(true){ function a(){} a = 2; a =3; } console.log(a) // a = 3;</code></p>
<h2 id="副作用">副作用</h2>
<p>但是会发现，变量a的值发生了变化。其实是因为函数声明会有<strong>副作用</strong>声明的确会提升，但是在原本的位置上，仍然会对程序有一定的影响。<br>
也就是程序在执行到原本的位置时候，会将块级作用域中的同名局部变量，同步到全局中的同名全局变量。<br>
在同一层块级作用域，会发生多次同步。而在嵌套if作用域中，只会发生第一次同步。</p>
<pre><code class="language-js">    var a = 1;
    if(true){
        a = 2;
        function a(){}
        if(true){
            a = 3;
            function a(){var b ;}
        }
    }

    console.log(a) // a = 2;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[History模式的路由]]></title>
        <id>https://czh.im/post/shi-xian-yi-ge-jian-dan-de-history-mo-shi-de-lu-you/</id>
        <link href="https://czh.im/post/shi-xian-yi-ge-jian-dan-de-history-mo-shi-de-lu-you/">
        </link>
        <updated>2020-04-06T04:25:50.000Z</updated>
        <content type="html"><![CDATA[<p>用一个类来实现简单的页面history模式路由。</p>
<ol>
<li>
<p>实现一个类</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll(&quot;[href]&quot;)
        this.view = document.querySelector('#router-view');
    }
    
	route(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
}
</code></pre>
</li>
<li>
<p>监听popState事件</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll(&quot;[href]&quot;)
        this.view = document.querySelector('#router-view');
        window.onpopstate = this.watchPopState
    }
    
	route(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
    watchPopState() {
        console.log('stoped')
    }
}
</code></pre>
</li>
<li>
<p>由于 pushState 和 replaceState 方法不能被 popState 事件监听到，所以需要重写方法并实现监听</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll('[href]')
        this.view = document.querySelector('#router-view');
        
        window.onpopstate = this.watchPopState
        //初始的history.State 为null
		//个人猜测，在history路由下，Vue打包后需要Nginx重定向就是因为如此，
        //刷新将找不到路径 / 下的资源
        history.pushState({
        	''/'':'/'
		},null)
        
        history.pushState = this.registry_history_event('pushState');
        history.replaceState = this.registry_history_event('replaceState');
        
        //使用bind是为了更方便的使用实例对象，在window上监听事件会将this指向window
        //这里不能使用window.onpushstate,会失效，在window上并没有这个方法，不会触发事件的监听
        window.addEventListener('pushState', this.onpushState.bind(this))
		window.addEventListener('replaceState', this.onreplaceState.bind(this))
    }
    
	route(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        //第二个参数是标题
        //第三个参数是将路径加入到导航栏
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
    watchPopState() {
        console.log('stoped')
    }
    onpushState(event) {
		console.log(&quot;pushed state&quot;)
        this.view.innerHTML = event.arguments[2];
	}

	onreplaceState(event) {
		console.log(&quot;replaced state&quot;)
        this.view.innerHTML = event.arguments[2];
    }
    
    registry_history_event(type) {
		const origin_fun = history[type];
		//origin_fun 执行的顺序将决定 事件回调和事件发生的先后顺序
        //比如改为 return origin_fun.call(this,...arguments)
        return function() {
		const result = origin_fun.call(this, ...arguments);
        	const e = new Event(type);
            //将参数传给事件
			e.arguments = arguments;
            //在window对象上触发事件
            window.dispatchEvent(e);
            return result;
	    }
	}
}
</code></pre>
</li>
<li>
<p>当自己想实现私有方法时，可以使用闭包</p>
<pre><code class="language-js">const router = (()=&gt;{
    const private_function = ()=&gt;{
        //...
    }
    class Router{
        //...
    }
    return new Router();
}())
</code></pre>
</li>
<li>
<p>而私有变量的实现就灵活的多，可以使用Symbol，WeakSet，闭包</p>
<pre><code class="language-js">//Symbol + 闭包
const router = (()=&gt;{
    const private_variable = Symbol();
    class Router{
        [private_variable] = &quot;some value&quot;
        //...
    }
    return new Router();
}())
</code></pre>
<pre><code class="language-js">//WeakMap + 闭包
const router = (()=&gt;{
    const private_variable = new WeakMap()
    class Router{
        constructor(){
	        private_variable.set(&quot;key&quot;,&quot;value&quot;)
        }
    }
    return new Router()
}())
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP入门]]></title>
        <id>https://czh.im/post/http-ru-men/</id>
        <link href="https://czh.im/post/http-ru-men/">
        </link>
        <updated>2020-04-04T04:47:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http-基本知识">HTTP 基本知识</h2>
<ol>
<li>
<p>http，超文本传输协议</p>
<p>在计算机网络中，<strong>两点</strong>之间<strong>传输</strong>文字，图片，视频等<strong>超文本</strong>数据的<strong>约定和规范</strong></p>
</li>
<li>
<p>五大类HTTP状态码</p>
<p><strong>1xx</strong>,提示信息，协议处理中的一种中间状态</p>
<p><strong>2xx</strong>,成功处理了请求</p>
<p><strong>3xx</strong>,请求的资源发生了变动，也就是重定向，也用于控制缓存（304 资源未修改）</p>
<p><strong>4xx</strong>,报文有误，服务端无法处理</p>
<p><strong>5xx</strong>，报文正确，服务端错误</p>
</li>
<li>
<p>常见的 HTTP字段</p>
<p>Host     发送请求时，指定服务器的域名</p>
<p>Content-Length  响应数据的长度，超过这个长度，就属于下一个请求了</p>
<p>Connection    	 表示长久连接，为了兼容老版本HTTP，值为Keep-Alive（默认）</p>
<p>Content-Type      表示响应数据的格式（text/html;charset=utf-8）</p>
<p>Accept                  表示请求接受的数据格式</p>
<p>Content-Encoding     说明数据的压缩方法</p>
<p>Accept-Encoding		希望数据的压缩方法（gzip，deflate）</p>
</li>
</ol>
<h2 id="get和post">GET和POST</h2>
<ul>
<li>
<p>GET 表示获取资源</p>
<p>安全且幂等</p>
</li>
<li>
<p>POST 表示提交数据</p>
<p>不安全，不幂等</p>
</li>
<li>
<p>安全</p>
<p>请求不会破坏服务器上的资源</p>
</li>
<li>
<p>幂等</p>
<p>多次请求，结果相同</p>
</li>
</ul>
<h2 id="http特性">HTTP特性</h2>
<ol>
<li>
<p>简单</p>
<p>报文格式简单：head+body</p>
</li>
<li>
<p>灵活易拓展</p>
<p>各类请求方法，URI/URL，状态码，头字段，都没有被固定死，允许开发人员自行扩充</p>
<p>同时  HTTP  工作在应用层，下层可以随意变化，比如 HTTPS 就是在HTTP和TCP之间加入了SSL/TLS安全传输层，HTTP3甚至把TCP换成了基于UDP的QUIC</p>
</li>
<li>
<p>应用广泛和跨平台</p>
</li>
<li>
<p>无状态</p>
<ul>
<li>导致了业务逻辑复杂</li>
<li>减轻服务器压力</li>
</ul>
</li>
<li>
<p>明文传输</p>
<ul>
<li>调试方便</li>
<li>不安全</li>
</ul>
</li>
<li>
<p>不安全</p>
<ul>
<li>通信使用明文</li>
<li>不验证通信方身份</li>
<li>不验证报文完整性</li>
</ul>
</li>
</ol>
<h2 id="http性能">HTTP性能</h2>
<ol>
<li>
<p>长连接</p>
<p>由于每次tcp的连接断开都需要三次握手和四次挥手，所以反复的连接和断开会造成性能的损耗</p>
<p>于是采用长连接的策略</p>
</li>
<li>
<p>管道网络传输</p>
<p>不必等待第一个请求响应完成，即可发出第二个请求，减少了整体的响应时间，但目前为止，服务端仍然是按顺序依次响应。</p>
</li>
<li>
<p>队头阻塞</p>
<p>当一个请求被阻塞，会导致后续的请求同样被阻塞</p>
</li>
</ol>
<h2 id="http-与-https">HTTP 与 HTTPS</h2>
<h3 id="https-特点">HTTPS 特点</h3>
<ul>
<li>在HTTP的基础上，加入了 SSL/TSL协议。</li>
<li>在TCP三次握手的基础上，进行SSL/TSL的四次握手过程，才进入加密报文传输过程。</li>
<li>HTTP的端口号是80，HTTPS的端口号是443</li>
<li>HTTPS需要向CA申请数字证书，来保证服务器自身是可信的</li>
</ul>
<h3 id="https-解决的问题">HTTPS 解决的问题</h3>
<ul>
<li>
<p>窃听风险（信息加密）----混合加密</p>
</li>
<li>
<p>篡改风险（完整性验证）----摘要算法</p>
</li>
<li>
<p>冒充风险（身份验证） --- 数字证书</p>
</li>
</ul>
<h2 id="过程">过程</h2>
<p>​	在进行TCP的三次握手之后，进行SSL的四次握手，双方交换信息以及随机数，获取服务端的证书，以及加密过后的随机数（pre-master key），通过pre-master来生成会话密钥，之后一直采用会话密钥进行加密</p>
<h2 id="演变">演变</h2>
<ol>
<li>
<p>HTTP</p>
<p>1.1 相比1.0 的改进</p>
<ul>
<li>增加了 PUT，DELETE 等新的方法</li>
<li>增加了缓存管理和控制</li>
<li>明确了连接管理，允许持久连接</li>
<li>允许响应数据分块，利于大文件传输</li>
<li>强制要求Host头，使得互联网主机托管成为可能</li>
<li>管道网络传输</li>
</ul>
<p>性能瓶颈</p>
<ul>
<li>响应头部未压缩就发送，首部信息越多延迟越大</li>
<li>发送冗长的信息，每次互相发送相同的消息会造成浪费</li>
<li>队头阻塞</li>
<li>没有优先级控制</li>
<li>只能从客户端请求，服务端响应</li>
</ul>
</li>
<li>
<p>HTTP/2</p>
<p>相比 1.1 的改进</p>
<ul>
<li>
<p>头部压缩</p>
</li>
<li>
<p>HPACK,客户端和服务端同时维护一张头部信息表，发送请求只需要发送索引号即可</p>
</li>
<li>
<p>二进制格式，头部和数据体统称为帧：头信息帧和数据帧。</p>
<p>增加了数据传输的效率</p>
</li>
<li>
<p>数据流<br>
一次长连接里面连续的数据包可能属于不同的响应，可以指定数据流的优先级</p>
</li>
<li>
<p>多路复用 ，废弃管道<br>
一次连接中可以<strong>并发</strong>多个请求或响应，不会出现<strong>对头阻塞</strong>问题，降低了延迟，提高了利用率<br>
服务器推送   主动向客户端发送消息</p>
</li>
<li>
<p>增强了安全行， 要求加密通信</p>
</li>
</ul>
<p>缺陷</p>
<ul>
<li>
<p>由于多个HTTP请求复用一个TCP连接，一旦发生丢包现象，就会触发TCP的重传机制。所有请求都等待丢了的包重传回来。</p>
<p>HTTP/1.1 ，一个请求阻塞，后续的请求也会阻塞</p>
<p>HTTP/2   一个请求丢包，会阻塞所有请求</p>
<p>原因是基于TCP的传输层</p>
</li>
</ul>
</li>
<li>
<p>HTTP/3</p>
<ul>
<li>
<p>改进</p>
<p>将TCP协议换成UDP协议，并使用QUIC协议来实现类似TCP的可靠传输</p>
<p>最终使得，某个流发生丢包，只会阻塞当前流，不会阻塞其他数据流</p>
<p>并且将TCP的三次握手和TLS1.3+的三次握手合并为三次</p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>