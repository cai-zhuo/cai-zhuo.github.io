<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://c739557637.github.io</id>
    <title>Gridea</title>
    <updated>2020-04-15T07:36:49.529Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://c739557637.github.io"/>
    <link rel="self" href="https://c739557637.github.io/atom.xml"/>
    <subtitle>看着自己</subtitle>
    <logo>https://c739557637.github.io/images/avatar.png</logo>
    <icon>https://c739557637.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[if块级作用域函数声明的副作用]]></title>
        <id>https://c739557637.github.io/post/if-kuai-ji-zuo-yong-yu-han-shu-sheng-ming-de-fu-zuo-yong/</id>
        <link href="https://c739557637.github.io/post/if-kuai-ji-zuo-yong-yu-han-shu-sheng-ming-de-fu-zuo-yong/">
        </link>
        <updated>2020-04-15T07:04:40.000Z</updated>
        <content type="html"><![CDATA[<p>在一般情况下，我们都会注意到函数声明时，会将函数提升到整个块级作用域的顶层。</p>
<pre><code class="language-js">var a = 1;
if(true){
    a = 2;
    function a(){}
    a = 3;
}
console.log(a) // a = 2;
</code></pre>
<p>一般我们默认为，function a (){}  语句 会提升到块级作用域的顶端</p>
<pre><code class="language-js">var a = 1;
if(true){
    function a(){}
    a = 2;
    a  =3;
}
console.log(a) // a = 3;
</code></pre>
<p>但是会发现，变量a的值发生了变化。<br>
其实是因为函数声明会有<strong>副作用</strong><br>
声明的确会提升，但是在原本的位置上，仍然会对程序有一定的影响。<br>
也就是程序在执行到原本的位置时候，会将块级作用域中的同名局部变量，同步到全局中的同名全局变量。<br>
在同一层块级作用域，会发生多次同步。而在嵌套if作用域中，只会发生第一次同步。</p>
<pre><code class="language-js">var a = 1;
if(true){
    a = 2;
    function a(){}
    if(true){
        a = 3;
        function a(){var b ;}
    }
}

console.log(a) // a = 2;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[History模式的路由]]></title>
        <id>https://c739557637.github.io/post/shi-xian-yi-ge-jian-dan-de-history-mo-shi-de-lu-you/</id>
        <link href="https://c739557637.github.io/post/shi-xian-yi-ge-jian-dan-de-history-mo-shi-de-lu-you/">
        </link>
        <updated>2020-04-06T04:25:50.000Z</updated>
        <content type="html"><![CDATA[<p>用一个类来实现简单的页面history模式路由。</p>
<ol>
<li>
<p>实现一个类</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll(&quot;[href]&quot;)
        this.view = document.querySelector('#router-view');
    }
    
	route_to(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
}
</code></pre>
</li>
<li>
<p>监听popState事件</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll(&quot;[href]&quot;)
        this.view = document.querySelector('#router-view');
        window.onpopstate = this.watchPopState
    }
    
	route_to(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
    watchPopState() {
        console.log('stoped')
    }
}
</code></pre>
</li>
<li>
<p>由于 pushState 和 replaceState 方法不能被 popState 事件监听到，所以需要重写方法并实现监听</p>
<pre><code class="language-js">class Router{
    links
    view
   
    constructor(){
        this.links = document.querySelectorAll('[href]')
        this.view = document.querySelector('#router-view');
        
        window.onpopstate = this.watchPopState
        //初始的history.State 为null
		//个人猜测，在history路由下，Vue打包后需要Nginx重定向就是因为如此，
        //刷新将找不到路径 / 下的资源
        history.pushState({
        	''/'':'/'
		},null)
        
        history.pushState = this.registry_history_event('pushState');
        history.replaceState = this.registry_history_event('replaceState');
        
        //使用bind是为了更方便的使用实例对象，在window上监听事件会将this指向window
        //这里不能使用window.onpushstate,会失效，在window上并没有这个方法，不会触发事件的监听
        window.addEventListener('pushState', this.onpushState.bind(this))
		window.addEventListener('replaceState', this.onreplaceState.bind(this))
    }
    
	route_to(event) {
        //简单的监听a标签
    	const path = event.target.getAttribute('href')
        event.preventDefault();
        //第二个参数是标题
        //第三个参数是将路径加入到导航栏
        history.pushState({
        	[path]: path
		}, null, path)
    }
    
    watchPopState() {
        console.log('stoped')
    }
    onpushState(event) {
		console.log(&quot;pushed state&quot;)
        this.view.innerHTML = event.arguments[2];
	}

	onreplaceState(event) {
		console.log(&quot;replaced state&quot;)
        this.view.innerHTML = event.arguments[2];
    }
    
    registry_history_event(type) {
		const origin_fun = history[type];
		//origin_fun 执行的顺序将决定 事件回调和事件发生的先后顺序
        //比如改为 return origin_fun.call(this,...arguments)
        return function() {
		const result = origin_fun.call(this, ...arguments);
        	const e = new Event(type);
            //将参数传给事件
			e.arguments = arguments;
            //在window对象上触发事件
            window.dispatchEvent(e);
            return result;
	    }
	}
}
</code></pre>
</li>
<li>
<p>当自己想实现私有方法时，可以使用闭包</p>
<pre><code class="language-js">const router = (()=&gt;{
    const private_function = ()=&gt;{
        //...
    }
    class Router{
        //...
    }
    return new Router();
}())
</code></pre>
</li>
<li>
<p>而私有变量的实现就灵活的多，可以使用Symbol，WeakSet，闭包</p>
<pre><code class="language-js">//Symbol + 闭包
const router = (()=&gt;{
    const private_variable = Symbol();
    class Router{
        [private_variable] = &quot;some value&quot;
        //...
    }
    return new Router();
}())
</code></pre>
<pre><code class="language-js">//WeakMap + 闭包
const router = (()=&gt;{
    const private_variable = new WeakMap()
    class Router{
        constructor(){
	        private_variable.set(&quot;key&quot;,&quot;value&quot;)
        }
    }
    return new Router()
}())
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP入门]]></title>
        <id>https://c739557637.github.io/post/http-ru-men/</id>
        <link href="https://c739557637.github.io/post/http-ru-men/">
        </link>
        <updated>2020-04-04T04:47:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http-基本知识">HTTP 基本知识</h2>
<ol>
<li>
<p>http，超文本传输协议</p>
<p>在计算机网络中，<strong>两点</strong>之间<strong>传输</strong>文字，图片，视频等<strong>超文本</strong>数据的<strong>约定和规范</strong></p>
</li>
<li>
<p>五大类HTTP状态码</p>
<p><strong>1xx</strong>,提示信息，协议处理中的一种中间状态</p>
<p><strong>2xx</strong>,成功处理了请求</p>
<p><strong>3xx</strong>,请求的资源发生了变动，也就是重定向，也用于控制缓存（304 资源未修改）</p>
<p><strong>4xx</strong>,报文有误，服务端无法处理</p>
<p><strong>5xx</strong>，报文正确，服务端错误</p>
</li>
<li>
<p>常见的 HTTP字段</p>
<p>Host     发送请求时，指定服务器的域名</p>
<p>Content-Length  响应数据的长度，超过这个长度，就属于下一个请求了</p>
<p>Connection    	 表示长久连接，为了兼容老版本HTTP，值为Keep-Alive（默认）</p>
<p>Content-Type      表示响应数据的格式（text/html;charset=utf-8）</p>
<p>Accept                  表示请求接受的数据格式</p>
<p>Content-Encoding     说明数据的压缩方法</p>
<p>Accept-Encoding		希望数据的压缩方法（gzip，deflate）</p>
</li>
</ol>
<h2 id="get和post">GET和POST</h2>
<ul>
<li>
<p>GET 表示获取资源</p>
<p>安全且幂等</p>
</li>
<li>
<p>POST 表示提交数据</p>
<p>不安全，不幂等</p>
</li>
<li>
<p>安全</p>
<p>请求不会破坏服务器上的资源</p>
</li>
<li>
<p>幂等</p>
<p>多次请求，结果相同</p>
</li>
</ul>
<h2 id="http特性">HTTP特性</h2>
<ol>
<li>
<p>简单</p>
<p>报文格式简单：head+body</p>
</li>
<li>
<p>灵活易拓展</p>
<p>各类请求方法，URI/URL，状态码，头字段，都没有被固定死，允许开发人员自行扩充</p>
<p>同时  HTTP  工作在应用层，下层可以随意变化，比如 HTTPS 就是在HTTP和TCP之间加入了SSL/TLS安全传输层，HTTP3甚至把TCP换成了基于UDP的QUIC</p>
</li>
<li>
<p>应用广泛和跨平台</p>
</li>
<li>
<p>无状态</p>
<ul>
<li>导致了业务逻辑复杂</li>
<li>减轻服务器压力</li>
</ul>
</li>
<li>
<p>明文传输</p>
<ul>
<li>调试方便</li>
<li>不安全</li>
</ul>
</li>
<li>
<p>不安全</p>
<ul>
<li>通信使用明文</li>
<li>不验证通信方身份</li>
<li>不验证报文完整性</li>
</ul>
</li>
</ol>
<h2 id="http性能">HTTP性能</h2>
<ol>
<li>
<p>长连接</p>
<p>由于每次tcp的连接断开都需要三次握手和四次挥手，所以反复的连接和断开会造成性能的损耗</p>
<p>于是采用长连接的策略</p>
</li>
<li>
<p>管道网络传输</p>
<p>不必等待第一个请求响应完成，即可发出第二个请求，减少了整体的响应时间，但目前为止，服务端仍然是按顺序依次响应。</p>
</li>
<li>
<p>队头阻塞</p>
<p>当一个请求被阻塞，会导致后续的请求同样被阻塞</p>
</li>
</ol>
<h2 id="http-与-https">HTTP 与 HTTPS</h2>
<h3 id="https-特点">HTTPS 特点</h3>
<ul>
<li>在HTTP的基础上，加入了 SSL/TSL协议。</li>
<li>在TCP三次握手的基础上，进行SSL/TSL的四次握手过程，才进入加密报文传输过程。</li>
<li>HTTP的端口号是80，HTTPS的端口号是443</li>
<li>HTTPS需要向CA申请数字证书，来保证服务器自身是可信的</li>
</ul>
<h3 id="https-解决的问题">HTTPS 解决的问题</h3>
<ul>
<li>
<p>窃听风险（信息加密）----混合加密</p>
</li>
<li>
<p>篡改风险（完整性验证）----摘要算法</p>
</li>
<li>
<p>冒充风险（身份验证） --- 数字证书</p>
</li>
</ul>
<h2 id="过程">过程</h2>
<p>​	在进行TCP的三次握手之后，进行SSL的四次握手，双方交换信息以及随机数，获取服务端的证书，以及加密过后的随机数（pre-master key），通过pre-master来生成会话密钥，之后一直采用会话密钥进行加密</p>
<h2 id="演变">演变</h2>
<ol>
<li>
<p>HTTP</p>
<p>1.1 相比1.0 的改进</p>
<ul>
<li>增加了 PUT，DELETE 等新的方法</li>
<li>增加了缓存管理和控制</li>
<li>明确了连接管理，允许持久连接</li>
<li>允许响应数据分块，利于大文件传输</li>
<li>强制要求Host头，使得互联网主机托管成为可能</li>
<li>管道网络传输</li>
</ul>
<p>性能瓶颈</p>
<ul>
<li>响应头部未压缩就发送，首部信息越多延迟越大</li>
<li>发送冗长的信息，每次互相发送相同的消息会造成浪费</li>
<li>队头阻塞</li>
<li>没有优先级控制</li>
<li>只能从客户端请求，服务端响应</li>
</ul>
</li>
<li>
<p>HTTP/2</p>
<p>相比 1.1 的改进</p>
<ul>
<li>
<p>头部压缩</p>
</li>
<li>
<p>HPACK,客户端和服务端同时维护一张头部信息表，发送请求只需要发送索引号即可</p>
</li>
<li>
<p>二进制格式，头部和数据体统称为帧：头信息帧和数据帧。</p>
<p>增加了数据传输的效率</p>
</li>
<li>
<p>数据流<br>
一次长连接里面连续的数据包可能属于不同的响应，可以指定数据流的优先级</p>
</li>
<li>
<p>多路复用 ，废弃管道<br>
一次连接中可以<strong>并发</strong>多个请求或响应，不会出现<strong>对头阻塞</strong>问题，降低了延迟，提高了利用率<br>
服务器推送   主动向客户端发送消息</p>
</li>
<li>
<p>增强了安全行， 要求加密通信</p>
</li>
</ul>
<p>缺陷</p>
<ul>
<li>
<p>由于多个HTTP请求复用一个TCP连接，一旦发生丢包现象，就会触发TCP的重传机制。所有请求都等待丢了的包重传回来。</p>
<p>HTTP/1.1 ，一个请求阻塞，后续的请求也会阻塞</p>
<p>HTTP/2   一个请求丢包，会阻塞所有请求</p>
<p>原因是基于TCP的传输层</p>
</li>
</ul>
</li>
<li>
<p>HTTP/3</p>
<ul>
<li>
<p>改进</p>
<p>将TCP协议换成UDP协议，并使用QUIC协议来实现类似TCP的可靠传输</p>
<p>最终使得，某个流发生丢包，只会阻塞当前流，不会阻塞其他数据流</p>
<p>并且将TCP的三次握手和TLS1.3+的三次握手合并为三次</p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EVENT LOOP]]></title>
        <id>https://c739557637.github.io/post/event-loop/</id>
        <link href="https://c739557637.github.io/post/event-loop/">
        </link>
        <updated>2020-04-04T03:21:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="在javascript运行机制中依赖event-loop决定代码先后执行的顺序">在JavaScript运行机制中，依赖EVENT LOOP，决定代码先后执行的顺序。</h2>
<p>Javascript执行过程</p>
<ol>
<li>执行栈内任务，遇到setTimeout，setImmediate，等API，将回调放入宏队列，遇到process.nextTick,Promise等，将回调放入微队列</li>
<li>将微队列的任务逐个推入主线程，将遇到的API回调放入相应队列</li>
<li>微队列空时并且栈空，将宏队列的任务逐个推到主线程</li>
<li>宏队列空时，将微队列的任务推入主线程（在nodeJS中，宏队列的每个阶段执行完毕时，都会去执行微队列）</li>
<li>直到所有队列任务执行完毕。</li>
</ol>
<ul>
<li>
<p>javaScript中。分为主线程（STACK），其他线程（WEB APIs,others），宏队列（macrotask），微队列(microtask)。</p>
</li>
<li>
<p>区别</p>
<ol>
<li>
<p>在浏览器中，微队列可以认为在宏队列之内</p>
<img src="https://segmentfault.com/img/remote/1460000016278118?w=710&amp;h=749" alt="browser-eventloop" style="zoom: 67%;" />
</li>
<li>
<p>在nodeJS中，微队列在宏队列之间，宏队列和微队列分为各个不同的队列</p>
<p>各队列同样依靠一个循环来决定执行顺序。</p>
<p><mark>宏队列</mark></p>
<img src="https://segmentfault.com/img/remote/1460000016278121?w=951&amp;h=526" alt="node-eventloop" style="zoom: 80%;" />
<p><mark>微队列</mark></p>
 <img src="https://segmentfault.com/img/remote/1460000016278122?w=420&amp;h=433" alt="node-microtaskqueue" style="zoom: 80%;" /> 
</li>
<li>
<p>在微队列中，NextTick QUeue优先于Other Micro Queue</p>
</li>
<li>
<p>在微队列周期中，新的任务进入了队列，那么这个任务也将在这个周期执行，但在宏队列中不是。</p>
</li>
<li>
<p>只有在栈空的时候才会考虑宏队列和微队列的任务</p>
<p>所以在事件执行时，手动触发 和 代码执行执行的顺序会有区别</p>
<pre><code class="language-js">div.addEventListener('click',()=&gt;{
    Promise.resolve().then(()=&gt;{
    	console.log(&quot;resolved&quot;);
	})
    setTimeout(()=&gt;{
        console.log(&quot;timeout&quot;)
    },0)
})
//方案1:
//tap twice  ...
//方案2:
//click();
//click()
</code></pre>
<p>结果如下</p>
<ul>
<li>
<p>tap twice..</p>
<blockquote>
<p>resolved</p>
<p>timeout</p>
<p>resolved</p>
<p>timeout</p>
</blockquote>
</li>
<li>
<p>run click() twice</p>
<blockquote>
<p>resolved</p>
<p>resolved</p>
<p>timeout</p>
<p>timeout</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javascript 技巧收集]]></title>
        <id>https://c739557637.github.io/post/javascript-ji-qiao-shou-ji/</id>
        <link href="https://c739557637.github.io/post/javascript-ji-qiao-shou-ji/">
        </link>
        <updated>2020-04-04T03:07:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>js通过valueOf获取引用类型的数字，toString获取引用类型的字符串</p>
</li>
<li>
<p>Math.floor (4.9) === 4</p>
<p>~~   4.9 ===  4</p>
<p>~~ - 4.9 === -5</p>
</li>
<li>
<p>取整 | 0</p>
<p>1.3 | 0 ===  1</p>
<p>-1.3 | 0 === -1</p>
</li>
<li>
<p>判断奇偶数</p>
<p>const num = 3</p>
<p>!! (num &amp; 1) === true</p>
<p>!! (num % 2) === true</p>
</li>
<li>
<p>强制参数（mandatory）</p>
<pre><code class="language-js">const mandatory = ()=&gt;{
    throw new Error('Missing Parameter!')
}

const foo = (bar = mandatory())=&gt;{
    return bar;
}
</code></pre>
</li>
<li>
<p>惰性载入函数</p>
<p>通过覆写函数，使得下一次不用再进行判断</p>
<pre><code class="language-js">function foo(){
    if(a != b){
        console.log('a')
    }else{
        console.log('b')
    }
}
//优化后
function foo(){
    if(a != b){
        foo = function(){
            console.log('a')
        }
    }else{
        foo = function(){
            console.log('b')
        }
    }
    foo();	// or return foo()
}
</code></pre>
</li>
<li>
<p>一次性函数</p>
<pre><code class="language-js">let foo = ()=&gt;{
    console.log('1')
    foo = ()=&gt;{
        console.log('2')
    }
}
</code></pre>
</li>
<li>
<p>按位取反巧用</p>
<pre><code class="language-js">~ 0  === -1  //true
~-1 ===   0 //true

const arr = [1,2,3];
~arr.indexOf(4) ? null :arr.push(4) ;
</code></pre>
</li>
</ol>
]]></content>
    </entry>
</feed>